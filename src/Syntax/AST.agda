-- File generated by the BNF Converter (bnfc 2.9.5).

-- Agda bindings for the Haskell abstract syntax data types.

module Syntax.AST where

open import Agda.Builtin.Char using (Char)
open import Agda.Builtin.Float public using () renaming (Float to Double)
open import Agda.Builtin.Int   public using () renaming (Int to Integer)
open import Agda.Builtin.Int using () renaming (pos to #pos)
open import Agda.Builtin.List using ([]; _∷_) renaming (List to #List)
open import Agda.Builtin.Nat using () renaming (Nat to #Nat)
open import Agda.Builtin.String using () renaming
  ( String to #String
  ; primStringFromList to #stringFromList
  )

String = #List Char

{-# FOREIGN GHC import Prelude (Bool, Char, Double, Integer, String, (.), error) #-}
{-# FOREIGN GHC import qualified Prelude #-}
{-# FOREIGN GHC import qualified Data.Text #-}
{-# FOREIGN GHC import qualified Syntax.Abs #-}
{-# FOREIGN GHC import Syntax.Print (printTree) #-}

postulate
  #Int      : Set
  #intToNat : #Int → #Nat
  #natToInt : #Nat → #Int

{-# COMPILE GHC #Int      = type Prelude.Int    #-}
{-# COMPILE GHC #intToNat = Prelude.toInteger   #-}
{-# COMPILE GHC #natToInt = Prelude.fromInteger #-}

data #Pair (A B : Set) : Set where
  #pair : A → B → #Pair A B

{-# COMPILE GHC #Pair = data (,) ((,)) #-}

data VersionToken : Set where
  versionToken : #Pair (#Pair #Int #Int) #String → VersionToken

{-# COMPILE GHC VersionToken = data Syntax.Abs.VersionToken (Syntax.Abs.VersionToken) #-}

data Number : Set where
  number : #Pair (#Pair #Int #Int) #String → Number

{-# COMPILE GHC Number = data Syntax.Abs.Number (Syntax.Abs.Number) #-}

data VariableName : Set where
  variableName : #Pair (#Pair #Int #Int) #String → VariableName

{-# COMPILE GHC VariableName = data Syntax.Abs.VariableName (Syntax.Abs.VariableName) #-}

mutual

  data TensorShape : Set where
    scalarDims : TensorShape
    tensorDims : (xs : #List Number) → TensorShape

  {-# COMPILE GHC TensorShape = data Syntax.Abs.TensorShape
    ( Syntax.Abs.ScalarDims
    | Syntax.Abs.TensorDims
    ) #-}

  data ArithExpr : Set where
    varExpr  : (x : VariableName) (xs : #List Number) → ArithExpr
    valExpr  : (x : Number) → ArithExpr
    negate   : (a : ArithExpr) → ArithExpr
    plus     : (as : #List ArithExpr) → ArithExpr
    minus    : (a : ArithExpr) (as : #List ArithExpr) → ArithExpr
    multiply : (as : #List ArithExpr) → ArithExpr

  {-# COMPILE GHC ArithExpr = data Syntax.Abs.ArithExpr
    ( Syntax.Abs.VarExpr
    | Syntax.Abs.ValExpr
    | Syntax.Abs.Negate
    | Syntax.Abs.Plus
    | Syntax.Abs.Minus
    | Syntax.Abs.Multiply
    ) #-}

  data BoolExpr : Set where
    greaterThan  : (a₁ a₂ : ArithExpr) → BoolExpr
    lessThan     : (a₁ a₂ : ArithExpr) → BoolExpr
    greaterEqual : (a₁ a₂ : ArithExpr) → BoolExpr
    lessEqual    : (a₁ a₂ : ArithExpr) → BoolExpr
    notEqual     : (a₁ a₂ : ArithExpr) → BoolExpr
    equal        : (a₁ a₂ : ArithExpr) → BoolExpr
    and          : (bs : #List BoolExpr) → BoolExpr
    or           : (bs : #List BoolExpr) → BoolExpr

  {-# COMPILE GHC BoolExpr = data Syntax.Abs.BoolExpr
    ( Syntax.Abs.GreaterThan
    | Syntax.Abs.LessThan
    | Syntax.Abs.GreaterEqual
    | Syntax.Abs.LessEqual
    | Syntax.Abs.NotEqual
    | Syntax.Abs.Equal
    | Syntax.Abs.And
    | Syntax.Abs.Or
    ) #-}

  data Assertion : Set where
    assert : (b : BoolExpr) → Assertion

  {-# COMPILE GHC Assertion = data Syntax.Abs.Assertion (Syntax.Abs.Assert) #-}

  data ElementType : Set where
    genericElementType    : ElementType
    elementTypeF16        : ElementType
    elementTypeF32        : ElementType
    elementTypeF64        : ElementType
    elementTypeBF16       : ElementType
    elementTypeF8E4M3FN   : ElementType
    elementTypeF8E5M2     : ElementType
    elementTypeF8E4M3FNUZ : ElementType
    elementTypeF8E5M2FNUZ : ElementType
    elementTypeF4E2M1     : ElementType
    elementTypeI8         : ElementType
    elementTypeI16        : ElementType
    elementTypeI32        : ElementType
    elementTypeI64        : ElementType
    elementTypeU8         : ElementType
    elementTypeU16        : ElementType
    elementTypeU32        : ElementType
    elementTypeU64        : ElementType
    elementTypeC64        : ElementType
    elementTypeC128       : ElementType
    elementTypeBool       : ElementType
    elementTypeString     : ElementType

  {-# COMPILE GHC ElementType = data Syntax.Abs.ElementType
    ( Syntax.Abs.GenericElementType
    | Syntax.Abs.ElementTypeF16
    | Syntax.Abs.ElementTypeF32
    | Syntax.Abs.ElementTypeF64
    | Syntax.Abs.ElementTypeBF16
    | Syntax.Abs.ElementTypeF8E4M3FN
    | Syntax.Abs.ElementTypeF8E5M2
    | Syntax.Abs.ElementTypeF8E4M3FNUZ
    | Syntax.Abs.ElementTypeF8E5M2FNUZ
    | Syntax.Abs.ElementTypeF4E2M1
    | Syntax.Abs.ElementTypeI8
    | Syntax.Abs.ElementTypeI16
    | Syntax.Abs.ElementTypeI32
    | Syntax.Abs.ElementTypeI64
    | Syntax.Abs.ElementTypeU8
    | Syntax.Abs.ElementTypeU16
    | Syntax.Abs.ElementTypeU32
    | Syntax.Abs.ElementTypeU64
    | Syntax.Abs.ElementTypeC64
    | Syntax.Abs.ElementTypeC128
    | Syntax.Abs.ElementTypeBool
    | Syntax.Abs.ElementTypeString
    ) #-}

  data InputDefinition : Set where
    inputDef     : (x : VariableName) (e : ElementType) (t : TensorShape) → InputDefinition
    inputOnnxDef : (x₁ : VariableName) (e : ElementType) (t : TensorShape) (x₂ : String) → InputDefinition

  {-# COMPILE GHC InputDefinition = data Syntax.Abs.InputDefinition
    ( Syntax.Abs.InputDef
    | Syntax.Abs.InputOnnxDef
    ) #-}

  data HiddenDefinition : Set where
    hiddenDef : (x₁ : VariableName) (e : ElementType) (t : TensorShape) (x₂ : String) → HiddenDefinition

  {-# COMPILE GHC HiddenDefinition = data Syntax.Abs.HiddenDefinition (Syntax.Abs.HiddenDef) #-}

  data OutputDefinition : Set where
    outputDef     : (x : VariableName) (e : ElementType) (t : TensorShape) → OutputDefinition
    outputOnnxDef : (x₁ : VariableName) (e : ElementType) (t : TensorShape) (x₂ : String) → OutputDefinition

  {-# COMPILE GHC OutputDefinition = data Syntax.Abs.OutputDefinition
    ( Syntax.Abs.OutputDef
    | Syntax.Abs.OutputOnnxDef
    ) #-}

  data CompStm : Set where
    isomorphicTo : (x : VariableName) → CompStm
    equalTo      : (x : VariableName) → CompStm

  {-# COMPILE GHC CompStm = data Syntax.Abs.CompStm
    ( Syntax.Abs.IsomorphicTo
    | Syntax.Abs.EqualTo
    ) #-}

  data NetworkDefinition : Set where
    networkDef : (x : VariableName) (cs : #List CompStm) (is : #List InputDefinition) (hs : #List HiddenDefinition) (os : #List OutputDefinition) → NetworkDefinition

  {-# COMPILE GHC NetworkDefinition = data Syntax.Abs.NetworkDefinition (Syntax.Abs.NetworkDef) #-}

  data Version : Set where
    vNNLibVersion : (x : VersionToken) → Version

  {-# COMPILE GHC Version = data Syntax.Abs.Version (Syntax.Abs.VNNLibVersion) #-}

  data Query : Set where
    vNNLibQuery : (v : Version) (ns : #List NetworkDefinition) (as : #List Assertion) → Query

  {-# COMPILE GHC Query = data Syntax.Abs.Query (Syntax.Abs.VNNLibQuery) #-}

-- Binding the pretty printers.

postulate
  printListNumber            : #List Number → #String
  printTensorShape           : TensorShape → #String
  printArithExpr             : ArithExpr → #String
  printListArithExpr         : #List ArithExpr → #String
  printBoolExpr              : BoolExpr → #String
  printListBoolExpr          : #List BoolExpr → #String
  printAssertion             : Assertion → #String
  printListAssertion         : #List Assertion → #String
  printElementType           : ElementType → #String
  printInputDefinition       : InputDefinition → #String
  printHiddenDefinition      : HiddenDefinition → #String
  printOutputDefinition      : OutputDefinition → #String
  printListInputDefinition   : #List InputDefinition → #String
  printListHiddenDefinition  : #List HiddenDefinition → #String
  printListOutputDefinition  : #List OutputDefinition → #String
  printCompStm               : CompStm → #String
  printListCompStm           : #List CompStm → #String
  printNetworkDefinition     : NetworkDefinition → #String
  printListNetworkDefinition : #List NetworkDefinition → #String
  printVersion               : Version → #String
  printQuery                 : Query → #String
  printString                : String → #String
  printVersionToken          : VersionToken → #String
  printNumber                : Number → #String
  printVariableName          : VariableName → #String

{-# COMPILE GHC printListNumber = \ xs -> Data.Text.pack (printTree (xs :: [Syntax.Abs.Number])) #-}
{-# COMPILE GHC printTensorShape = \ t -> Data.Text.pack (printTree (t :: Syntax.Abs.TensorShape)) #-}
{-# COMPILE GHC printArithExpr = \ a -> Data.Text.pack (printTree (a :: Syntax.Abs.ArithExpr)) #-}
{-# COMPILE GHC printListArithExpr = \ as -> Data.Text.pack (printTree (as :: [Syntax.Abs.ArithExpr])) #-}
{-# COMPILE GHC printBoolExpr = \ b -> Data.Text.pack (printTree (b :: Syntax.Abs.BoolExpr)) #-}
{-# COMPILE GHC printListBoolExpr = \ bs -> Data.Text.pack (printTree (bs :: [Syntax.Abs.BoolExpr])) #-}
{-# COMPILE GHC printAssertion = \ a -> Data.Text.pack (printTree (a :: Syntax.Abs.Assertion)) #-}
{-# COMPILE GHC printListAssertion = \ as -> Data.Text.pack (printTree (as :: [Syntax.Abs.Assertion])) #-}
{-# COMPILE GHC printElementType = \ e -> Data.Text.pack (printTree (e :: Syntax.Abs.ElementType)) #-}
{-# COMPILE GHC printInputDefinition = \ i -> Data.Text.pack (printTree (i :: Syntax.Abs.InputDefinition)) #-}
{-# COMPILE GHC printHiddenDefinition = \ h -> Data.Text.pack (printTree (h :: Syntax.Abs.HiddenDefinition)) #-}
{-# COMPILE GHC printOutputDefinition = \ o -> Data.Text.pack (printTree (o :: Syntax.Abs.OutputDefinition)) #-}
{-# COMPILE GHC printListInputDefinition = \ is -> Data.Text.pack (printTree (is :: [Syntax.Abs.InputDefinition])) #-}
{-# COMPILE GHC printListHiddenDefinition = \ hs -> Data.Text.pack (printTree (hs :: [Syntax.Abs.HiddenDefinition])) #-}
{-# COMPILE GHC printListOutputDefinition = \ os -> Data.Text.pack (printTree (os :: [Syntax.Abs.OutputDefinition])) #-}
{-# COMPILE GHC printCompStm = \ c -> Data.Text.pack (printTree (c :: Syntax.Abs.CompStm)) #-}
{-# COMPILE GHC printListCompStm = \ cs -> Data.Text.pack (printTree (cs :: [Syntax.Abs.CompStm])) #-}
{-# COMPILE GHC printNetworkDefinition = \ n -> Data.Text.pack (printTree (n :: Syntax.Abs.NetworkDefinition)) #-}
{-# COMPILE GHC printListNetworkDefinition = \ ns -> Data.Text.pack (printTree (ns :: [Syntax.Abs.NetworkDefinition])) #-}
{-# COMPILE GHC printVersion = \ v -> Data.Text.pack (printTree (v :: Syntax.Abs.Version)) #-}
{-# COMPILE GHC printQuery = \ q -> Data.Text.pack (printTree (q :: Syntax.Abs.Query)) #-}
{-# COMPILE GHC printString = \ x -> Data.Text.pack (printTree (x :: String)) #-}
{-# COMPILE GHC printVersionToken = \ x -> Data.Text.pack (printTree (x :: Syntax.Abs.VersionToken)) #-}
{-# COMPILE GHC printNumber = \ x -> Data.Text.pack (printTree (x :: Syntax.Abs.Number)) #-}
{-# COMPILE GHC printVariableName = \ x -> Data.Text.pack (printTree (x :: Syntax.Abs.VariableName)) #-}
